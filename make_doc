#!/usr/bin/perl

#  Name:
#    make_doc

#  Purpose:
#    Produce the HTML docs for starlink.Ast

#  Usage:
#    make_doc <sun211.tex>

#  Paramaters:
#    <sun211.tex>
#       The full path to a copy of file sun211.tex (the C docs for AST).
#       Defaults to /star/docs/sun211.tex if not supplied.

#  Description:
#    This script is not intended to be distributed to PyAST users. It
#    auto-generates some of the docs files from the C source code, which
#    are committed in the repository as separate items and are distributed
#    to pyast users.
#
#    Pyast docs are stored in the same github repository as the pyast
#    code, but on branch "gh-pages". Github ensures that these pages
#    are published automatically on URL http://timj.github.io/starlink-pyast/
#
#    It should probably be re-written in Python, but since it is not
#    distributed, the langiage is not too important.
#
#    It gets a list of all public AST functions by scanning
#    /star/docs/sun211.tex. It then scans starlink/ast/Ast.c to see
#    which of these functions are implemented. It then produces the
#    following output HTML files:
#
#       node1.html - A list of the implemented functions with
#       their Python API and links to the corresponding section of SUN/211
#
#       node2.html - A list of the unimplemented functions with
#       links to the corresponding section of SUN/211.
#
#       pyast.html - The contents of dochead.html and doctail.html
#       are copied to the start and end of pyast.html. The middle
#       is generated automatically and is a collection of links to fragments
#       of node1.html that describe all the implemented functions.

#  Get the path to a local copy of the C docs (SUN/211).
$sun211 = $ARGV[0];
if( not defined $sun211 ) {
   $sun211 = "/star/docs/sun211.tex";
}

#  Identify all public AST functions by examining the tex source for
#  SUN/211. We create several hashes containing information about the
#  subset of public functions for which pyast provides a wrapper. These
#  hashes are keyed by the function name (e.g. "AddFrame", etc). The
#  hashes are:
#
#  "invokes": Each entry describes an invocation of the corresponding pyast function.
#  "notes": Each entry contains any notes for the pyast function, read from Ast.c.
#  "static": Non-zero if the function is a static (i.e. class) function.

#  The following hash has entries for all AST functions, whether a pyast
#  wrapper exists or not:
#
#  "purpose": A brief description of the purpose of each function.


open( IN, $sun211 ) or die "Cannot open $sun211";
$state = 0;
$iline = 0;
$pur = "";
while( $line = <IN> ){
   chomp($line);
   $iline++;

#  Check if we have found the start of the section containing the function
#  descriptions.
   if( $state == 0 ) {
      if( $line =~ /^\\section\{.*AST Function Descriptions.*\}$/ ) {
         $state = 1;
      }

#  Check if we have found the start of a new function description. Leave the
#  loop when all functions have been done (i.e. when a new section is
#  encountered).
   } elsif( $state == 1 ) {
      if( $line =~ /^\\section/ ) {
         last;
      } elsif( $line =~ /^\\sstroutine *\{/ ) {
         $state = 2;
      }

#  Look for the function name (label).
   } elsif( $state == 2 ) {
      if( $line =~ / *ast(\w+)(\$.*\$)?/ ) {
         $funcname = $1;
      }
      $state = 3;

#  Skip the following "}{" line.
   } elsif( $state == 3 ) {
      if( $line =~ /\}\{/ ) {
         $state = 4;
      } else {
         print("Unexpected text at line $iline:\n$line");
         exit;
      }

#  Read the rest of the function docs. The current $line should be the function
#  purpose text.
   } elsif( $state == 4 ) {

#  Arrive here once the function purpose has been read.
      if( $line =~ /\}\{/ ) {

#  Construct regular expressions which match the three possible forms in which
#  the function may be declared within the pyast interface file (Ast.c).
         if( $funcname eq "TranN" ) {
            $meth = "tran";
         } else {
            $meth = lc($funcname);
         }
         $method_pat = "^static .* +\\*?(\\w+)_$meth\\(.*\\{";
         $method_gpat = "^static .* +\\*?(\\w+)_$meth##\\w+\\(.*\\{";
         $constructor_pat = "^static +int +".$funcname."_init\\(.*\\{";

#  Open the pyast interface file (Ast.c) and read through it until we find a
#  line that matches one of the above regular expressions.
         open( IN2, "<starlink/ast/Ast.c" );
         $found = 0;
         $isgeneric = 0;
         $isstatic = 0;
         $got_args = 0;
         $outlist = ' ';
         $inlist = ' ';
         $note = ' ';
         @items = ();
         while( $line2 = <IN2> ){
            chomp($line2);
            $line2 =~ s/ *\\ *$//;

#  If we have not yet found a match, check now. Note some properties
#  of the function if a match is found.
            if( !$found ) {
               if( $line2 =~ /$method_pat/ ) {
                  $iscon = 0;
                  $class = lc($1);
                  if( $class eq "pyast" ) {
                     $class = "starlink.Ast";
                     $isstatic = 1;
                  }
                  $found = 1;
               } elsif( $line2 =~ /$method_gpat/ ) {
                  $isgeneric = 1;
                  $iscon = 0;
                  $class = lc($1);
                  $found = 1;
               } elsif( $line2 =~ /$constructor_pat/ ) {
                  $iscon = 1;
                  $class = $funcname;
                  $found = 1;
               }

#  If we have previously found a match, read the special comment line that
#  gives information about the python inputs and outputs.
            } elsif ( $line2 =~ /\/\* +args: (.*):(.*) *\*\//i ) {
               $got_args = 1;
               @outs = split( / *, */, $1 );
               if ( @outs == 1 ) {
                  $outlist = $outs[0]." = ";
               } elsif( @outs > 1 ) {
                  $outlist = "( ".join( ', ', split( / *, */, $1 ) )." ) = ";
               }
               $inlist = join( ', ', split( / *, */, $2 ) );

#  If we have previously found a match, read the special comment lines that
#  contain any notes to be included with the function in the python docs.
           } elsif ( $line2 =~ /\/\* +Note: *(.*)$/i ) {
               $note = $1;

#  If we reach a line containing PyObject, then Ast.c is missing the special
#  "args:" line for this function!!
            } elsif( $line2 =~ /PyObject/ ){
               if( !$got_args ) {
                  print("No args list found for $funcname\n");
               }
               last;

#  Extend any note to include text from the new line.
            } elsif ( $note ne ' ' ){
               $note .= " ".$line2;
            }

#  Each note is a separate comment in Ast.c. Store all notes in
#  the "items" array.
            if ( $note =~ /(.*)\*\// ){
               $note = join( ' ', split( /\s+/, $1 ) );
               push( @items, $note );
               $note = ' ';
            }
         }
         close(IN2);

#  If the function name was found in Ast.C, include it in the following hashes.
         if( $found ) {
            if( $iscon ) {
               $invokes{$funcname} = "$meth = starlink.Ast.$class( $inlist )";
            } elsif( $isgeneric ){
               $funcname .= "&lt;X&gt;";
               $invokes{$funcname} = $outlist.$class.".$meth&lt;X&gt;( $inlist )\n";
            } else {
               $invokes{$funcname} = $outlist.$class.".$meth( $inlist )\n";
            }
            $isstat{$funcname} = $isstatic;
            if( @items > 0 ) {
               $notes{$funcname} = join( 'zzz', @items );
            }
         }

#  Store the purpose of every sun/211 function (whether or not it has a pyast wrapper).
         $purposes{$funcname} = $pur;

#  Start looking for the next function within sun/211.
         $pur = "";
         $state = 1;

#  Put the function purpose text into $pur.
      } elsif( $line =~ /^ *(.*) *$/ ) {
         $pur .= "$1 ";

#  Should never get here...
      } else {
         print("Unexpected text at line $iline:\n$line");
         exit;
      }
   }
}






#  Having gathered all the required information from sun/211 and
#  Ast.c, we now generate the output HTML files.

#  The URL of the starlink documents server - used to access on-line
#  version of SUN/211. This service determines the current URL of the page
#  describing a particular method.
$stardocs = "http://www.starlink.ac.uk/cgi-bin/htxserver";

#  "node1.html" contains information about all the AST functions for
#  which pyast provides wrappers.
open( OUT, ">node1.html" );

#  A static header...
print OUT <<EOF;
<html>
<head>
<style type="text/css">
div.implemented {position:relative;
                 left:30px;
                 margin-top:40px;
                 margin-bottom:40px}

div.implemented ul {list-style-type:none;padding-top:0px;margin-top:15px}
li.note {margin-top:10px;
         margin-left:30px;
         margin-right:80px;
         list-style-type:circle;}
span.inv {background-color:#FFFFDD;
          padding-top:3px;
          padding-bottom:3px;
          padding-left:13px;
          padding-right:13px;
          font-family: monospace;
          border:1px solid #DDD;}
</style>
</head>
<body>
<h2>Implemented AST functions</h2>

The starlink.Ast module provides Python wrappers for the following AST
functions. For each function, the corresponding Python API is displayed
on a yellow background, together with any explanatory notes. For
information about the purpose and parameters of each function, click on
the "ast..." function name to display the AST reference documentation
from SUN/211.
<p>
For examples of calling these wrappers, see the PyAST test script
(file starlink/ast/test/test.py within the pyast source distribution).
<p>
General Notes:
<ul>
<li> A returned value of "<code>result</code>" refers to the function value
returned by the corresponding C function.
<li> When the C documentation refers to a <i>NULL</i> pointer, "<code>None</code>" should be
used instead.
<li> Parameters that are optional in the Python API are indicated by
strings of the form "<code>name=default</code>".
<li> Constructors are shown preceeded by the full module name
"<code>starlink.Ast</code>".
<li> Methods are shown preceeded by a reference with name equal to the class
that provides the method.
</ul>
<hr>
<p>
EOF

#  Now add a descrption of each AST function for which a pyast wrapper exists.
foreach $key (sort keys %purposes) {
   if( $invokes{$key} ) {
      print OUT "<div class=\"implemented\" id=\"$key\">\n";
      print OUT "&#149; &nbsp; <a href=\"$stardocs/sun211.htx/?xref_ast$key\">ast$key</a> - $purposes{$key}\n";
      print OUT "<ul>\n";
      print OUT "<li><span class=inv>$invokes{$key}</span></li>\n";
      if( $isstat{$key} ) {
         print OUT "<li class=\"note\">This is a static module function.</li>\n";
      }

#  Check notes for references to ast functions (e.g. "<*astGetC*>", and replace
#  them with links to the SUN/211 docs.
      foreach $note (split /zzz/, $notes{$key} ) {
         $note =~ s/<\*(\S+)\*>/<a href="$stardocs\/sun211.htx\/?xref_$1">$1<\/a>/g;
         print OUT "<li class=\"note\">$note</li>\n";
      }
      print OUT "</ul>\n";
      print OUT "</div>\n";
   }
}

#  Static footer.
print OUT <<EOF;
</body>
</html>
EOF

close( OUT );






#  "node2.html" contains a list of all the AST functions for which no
#  pyast wrapper has yet been written.
open( OUT, ">node2.html" );

#  Static header...
print OUT <<EOF;
<html>
<head>
</head>
<body>
<h2>AST functions with no python wrapper</h2>
The following AST functions cannot currently be used in python. Further functions
will be added to pyast as and when people ask for them.
<p><ul>
EOF

#  List each AST function name for which there is a purpose but no pyast invocation.
foreach $key (sort keys %purposes) {
   if( ! $invokes{$key} ) {

      if( $key eq "Tran1" || $key eq "Tran2" ) {
         $extra = " (now covered by astTranN)";
      } else {
         $extra = '';
      }
      print OUT "<div class=\"unimplemented\">\n";
      print OUT "<a href=\"$stardocs/sun211.htx/?xref_ast$key\">ast$key - $purposes{$key}</a>$extra<br>\n";
      print OUT "</div>\n";
   }
}

#  Static footer...
print OUT <<EOF;
</ul></body>
</html>
EOF

close( OUT );





#  "pyast.html" is the top-level pyast docs page.
open( OUT, ">pyast.html" );

#  Since it is larger, read in the static header from a separate file
#  "dochead.html" rather than including it verbatim within this file.
#  Substitute date and pyast version number into the html.

($day, $month, $year) = (localtime)[3,4,5];

$tens = $day/10;
$units = $day%10;
if( $tens == 1 ) {
  $ord = "th";
} elsif( $units == 1 ) {
  $ord = "st";
} elsif( $units == 2 ) {
  $ord = "nd";
} elsif( $units == 3 ) {
  $ord = "rd";
} else {
  $ord = "th";
}
@MONTHS = ("January","February","March","April","May","June","July","August","September","October","November","December");
$year += 1900;
$date = "$day$ord $MONTHS[$month] $year";

open(FILE,"setup.py");
local $/ = undef;
$lines = <FILE>;
close(FILE);
$lines =~ / +version *= *'(\S+)',/;
$version = $1;

open( IN, "<dochead.html" );
while( $line = <IN> ){
   $line =~ s/<\*date\*>/$date/;
   $line =~ s/<\*version\*>/$version/;
   print OUT $line;
}
close( IN );

#  Add links to all implemented wrappers within "node1.html".
print OUT "<ul>\n";
foreach $key (sort keys %purposes) {
   if( $invokes{$key} ) {
      print OUT "<li><a href=\"node1.html#$key\">ast$key - $purposes{$key}</a>\n";
   }
}
print OUT "</ul>\n";

#  Static footer...
open( IN, "<doctail.html" );
while(<IN>){
   print OUT;
}
close( IN );
close( OUT );


