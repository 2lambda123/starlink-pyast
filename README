starlink.Ast is a Python extension that provides an interface to
Starlink AST library. To install the module AST source directory must
be available on the system via the AST_SOURCE environment variable.
Then ensure the environment variable STARLINK_DIR is
defined and do:

python3 setup.py install

or

python3 setup.py install --prefix=<your specific installation directory>

To test it, do

python3 starlink/ast/test/test.py


General Notes:
--------------

- In AST the word "attribute" is always used to refer to a property (i.e.
an item of data) stored within a class instance. In the AST sense, object
methods and attributes are distinct. The attributes and methods of each
AST class are listed in SUN/211.

- Each AST object class has a corresponding Python class (e.g. the AST
ZoomMap class corresponds to Python type starlink.Ast.ZoomMap)

- Each constant defined in ast.h has a corresponding Python constant. For
instance, the AST__TUNULL constant is available as starlink.Ast.TUNULL.

- A reference to the Python object "None" is used whenever an AST method
would returned a NULL object pointer.

- Unless otherwise stated, the argument lists for all AST functions and
methods are as listed in SUN/211 (special cases are listed below under
"Special Cases"). A general rule is that the value returned by an Ast
Python interface function will in general be a tuple. If the C AST
function returns a non-void function value, it will be the first element
in the tuple. Any other values returned by the C function via supplied C
pointers will be returned as subsequent elements of the tuple, in the
order in which the C pointers appear in the argument list of the C
function. If the C function does not return any values via C pointers,
then the returned Python value will be a single object reference rather
than a tuple. If additionally, the C function returns void, then the
returned Python value will be a reference to the "None" object.

As an example, the C astDecompose function has the following interface:

void astDecompose( AstMapping *this, AstMapping **map1, AstMapping **map2,
                   int *series, int *invert1, int *invert2  )


and the corresponding starlink.Ast.decompose method is invoked as:

map1,map2,series,invert1,invert2 = this.decompose()

The astDecompose function returns void - if it had returned a non-void
value this value would have been the first element in the returned tuple.

- Until some documentation is written, consult the module test script
(starlink/ast/test/test.py) for examples of how to call specific methods.

- Each Python method name is the lower case equivalent of the corresponding
AST method name.

- The standard "options" argument taken by all AST object constructors is
optional in the Python interface.

- Each AST Object "attribute" (as listed in SUN/211) has a corresponding
Python property with the same name. So for instance, either of the following
can be used to set the "Zoom" attribute (the zoom factor) in a ZoomMap
refered to by "zm":

   >>> zm.set("Zoom=1.2")
   >>> zm.Zoom = 1.2

Note, some AST attributes are multi-valued, with individual values being
refered to by attribute names of the form "name(index)" (i.e. the
attribute name followed by a numerical of string index in parentheses).
The corresponding Python properties are of the form "name_index" (i.e.
the index is appended with an underscore rather than being enclosed in
parentheses). For instance, either of the following will set the Label
attribute for the second axis of a Frame:

   >>> frm.set("Label(2)=Flux density")
   >>> frm.Label_2 = "Flux density"

and this will set the colour of a Plot border to colour index 1:

   >>> plot.set("Colour(Border)=1")
   >>> Plot.Colour_Border = 1

- The PVi_m attribute (defined by the WcsMap class) has no corresponding
python properties. To access this attribute, use the set and get methods
instead.

- Ast attributes can be retrieved using the AST "Get" method or the
corresponding Python property:

>>> print( zm.get("Zoom") )
>>> print( zm.Zoom )

The "Get" method is equivalent to astGetC (see SUN/211) in that it always
returns the string representation of the AST attribute value. Each Python
property return the attribute value using the native data type of the
AST attribute (integer, boolean, floating point or string).

- Testing and clearing AST attributes can only be done using the "test"
and "clear" methods (astsee SUN/211):

>>> zm.clear("Zoom")
>>> zm.test("Zoom")

- If an AST function fails, it will raise a Python Exception. Each AST
error code listed in the AST header file "ast.h" has a corresponding
subclass of Exception (e.g. the Exception subclass starlink.Ast.ZOOMI is
raised if an AST function returns an error code of AST__ZOOMI). All of
these Exception subclasses inherit from the single Exception type
starlink.Ast.AstError, which itself inherits from Exception.

- The following AST methods are not implemented in the Python interface
as they are superceded by infrastructure provided by the Python language
itself: astAnnul, astBegin, astClone, astDelete, astEnd, astExempt, astExport,
astImport, astGet<X> (except astGetC, see above), astSet<X>.

- A deep copy of an AST Object can be made either using the Python "copy"
module (e.g. "newobj = copy.deepcopy(obj)"), or using the standard AST
"copy" method (e.g. "newobj = obj.copy()").

- Boolean values in the AST interface can usually be passed integers
or True/False. True/False booleans are not enforced (but this may
change).


Special Cases:
--------------

- The Python interface does not currently include astTran1 or astTran2.
The interface for astTranN is

  result = mapping.trann( in, forward, out )

where "forward" is a boolean, and "in" is a 1- or 2-dimensional numpy
array of floating point values, or any sequence (lists, tuples, etc.)
that can be converted to a numpy array. A 1-dimensional array is only
allowed if the mapping has exactly one input, in which case the length of
the array gives the number of positions to be transformed. If a
2-dimensional array is supplied, its shape should be (Nin,npoint), where
Nin is the number of inputs for the Mapping, and npoint is the number of
positions to transform. The "out" argument is optional. If supplied, it
should be an existing 1- or 2-dimensional numpy array with a shape of
(npoint) (if 1-dimensional) or (Nout,npoint) (if 2-dimensional), where
Nout is the number of outputs from the Mapping and npoint is the number
of positions being transformed. A 1-dimensional array may be supplied
only if Nout is 1. If supplied, the transformed values are stored in the
supplied array. If not supplied, a new array with suitable shape is
created to store the transformed positions. IN either case, the value
returned by the method is a new reference to the array storing the
transformed values.

- The Python interface for astTranGrid is

  pout = mapping.trangrid( lbnd, ubnd, tol, maxpix, forward )

where "lbnd" and "ubnd" are 1-dimensional numpy arrays of integers, or
any sequence (lists, tuples, etc.) that can be converted to a numpy
array. The length of these arrays must equal the number of inputs for the
Mapping. The returned value (pout) is a 2-dimensional numpy array holding
the mapping output values at the grid points.

- Methods for which AST provides variants for different data types (e.g.
astRebin, astRebinSeq, astResample, etc) are unified into one method in
the Python interface. The names of such function are the same as the AST
names, but without any final letter indicating the data type (e.g.
astRebinD, astRebinF and astRebinI are replaced by
starlink.Ast.Mapping.rebin). The data type to use is determined from the
supplied array containing the input data.

- The C interface to astNorm modifies the array in place. The python
interface returns a new modified copy of the input array:

 normalised = frame.norm( input )

- Frame.ActiveUnit is treated as an attribute in the Python interface
rather than being implemented as two distinct method calls (astGetActiveUnit
and astSetActiveUnit).

- For SpecFrames astSetRefPos takes two separate arguments for the lon
and lat and GetRefPos returns a tuple with two values. It may be that
we should be using numpy arrays here.

- The Python interface for astResample has no "finterp" parameter, and
the AST__UKERN1 and AST__UINTERP interpolation schemes are not supported.

- The python interface for the Channel constructor (and the constructors
for all sub-classes of Channel) takes optional Source and Sink arguments.
If supplied (and not equal to None), the Source argument can be either a
sequence, or a reference to an object that implements a method called
"source". If it is a sequence, a line of text describing the object is
read from each element of the sequence. If "Source" is an object that
implements the "source" method, then on each invocation, the source
method should read the next line of text from some external source and
return it (or return None if there is no more text to return). Likewise,
if supplied, the Sink argument should be a reference to an object that
implements a method called "sink". On each invocation, the sink method
will be provided with the next line of text as its (only) argument - it
should write this text to some external data sink.

As an example of using a sequence, the "Source" argument for a FitsChan
constructor could be a PyFITS "CardList" describing the header of a FITS
file:

import pyfits
import starlink.Ast
fitsfile = pyfits.open('test.fit')
fc = starlink.Ast.FitsChan( fitsfile[0].header.ascardlist() )


- The FitsChan class is an iterable class (e.g. if "fc" is a reference to
a FitsChan, you can loop round all cards in the FitsChan by doing "for
card in fitschan:"). However, this is achieved by incrementing the Card
attribute of the FitsChan. So the looping will be affected by any other
operation that changes the Card attribute of the FitsChan during the
loop.

- The FitsChan class can be used as a python mapping. So for instance, if
"fc" is a reference to a FitsChan, you can assign a value to the NAXIS1
keyword by doing "fc["NAXIS1"]=1200". If a card for the keyword already
exists in the FitsChan, the value of the card will be changed. If the
FitsChan does not contain a card for the named keyword, a new card will
be appended to the end of the FitsChan. You can retrieve the value of the
a keyword in a similar way: for instance, "crval1 = fc["CRVAL1"]". Note,
if a keyword occurs more than once in a FitsChan, the the retrieved value
will be a tuple containing all the individual keyword values.

If a FitsChan is index using integers, the value returned is the whole
80-column header card at the given zero-based index. When assigning to an
element of a FitsChan indexed by an integer, the assigned value should be
a whole 80-column header card, which will overwrite the existing card at
the given index. If the index is larger than the number of cards in the
FitsChan, the new card will be appended to the end of the FitsChan.

- Currently, none of the methods available within AST for the KeyMap
class are available in Python. However, KeyMaps can be created in the
usual way, and entries can be written to or read from a KeyMap using the
syntax of a Python mapping (e.g. "keymap['fred'] = 1.2"). Note, only
strings and integers should be used as keys with a KeyMap. If a string is
used, the returned value is the value of the KeyMap entry with the
specified key. If an integer is used, the returned value is a tuple
containing the key and value of the corresponding entry in the KeyMap
(the order in which entries are returned is specified by the SortBy
attribute of the KeyMap). When setting a value, a starlink.Ast.MPIND
exception is reported if the specified zero-based integer index is
greater than or equal to the number of entries in the KeyMap.

Also, a KeyMap is iterable. Each value is returned as a (key,value) tuple.

The argument list for the MatrixMap constructor contains just an array
of matrix element values, and the usual optional list of AST attribute
settings. The array must be either 1- or 2- dimensional. If it is
1-dimensional, it is assumed to contain the values for the diagonal of
the (square) matrix, all other elements being zero. In this case the
length of the array determines the number of inputs and outputs for the
Matrixmap. If the array is 2-dimensional, it should consist of a list in
which element is a list of values for a single row of the matrix. For
instance, the 2-dimensional array [[1,2,3],[4,2,1]] specifies a matrix
with two rows and three columns. The resulting MatrixMap would have Nin=3
and Nout=2.

