<html>
<head>
<style type="text/css">
pre.pycode {display:inline-block;
             background-color:#FFFFDD;
             margin-top:0px;
             margin-left:40px;
             padding-top:10px;
             padding-bottom:10px;
             padding-left:13px;
             padding-right:13px;
             font-family: monospace;
             border:1px solid #DDD;}
</style>
</head>
<body>

<h2>Examples</h2>
This section contains some examples of PyAST code. Some of these
operation can be simplified by using the <a href="node5.html">higher-level
functions</a> in the <code>starlink.Atl</code> module, which provide wrappers
for some of the code fragments shown below.
<p>
In general, these examples show the Python equivalent of the
corresponding example in the "How To..." section of the documentation for
the native C version of AST,
<a href="http://www.starlink.ac.uk/cgi-bin/htxserver/sun211.htx/sun211.html?xref_">
SUN/211</a>, which should be consulted for further information on each
example.




<h4>...Read a WCS Calibration from a Dataset</h4>
<pre class=pycode>
import pyfits
import starlink.Ast as Ast

#  Open the FITS file using (for instance) pyfits. A list of the HDUs
#  in the FITS file is returned.
hdu_list = pyfits.open( 'test.fit' )

#  Create a FitsChan and fill it with the FITS header cards in the
#  primary HDU (element zero of the list returned by pyfits.open).
fitschan = Ast.FitsChan( hdu_list[ 0 ].header.ascardlist() )

#  Read WCS information from the FitsChan.
wcsinfo = fitschan.read()

</pre>




<h4>...Validate WCS Information</h4>
<pre class=pycode>

#  Check that the FITS header contained WCS in a form that can be
#  understood by AST.
if wcsinfo == None:
   print( "Failed to read WCS information from test.fit" )

#  Check that the object read from the FitsChan is of the expected class
#  (Ast.FrameSet).
elif not isinstance( wcsinfo, Ast.FrameSet ):
   print( "A "+wcsinfo.__class__.__name__+" was read from test.fit - "
          "was expecting an Ast.FrameSet" )

#  This particular code example can only handle WCS with 2 pixel axes
#  (given by Nin) and 2 WCS axes (given by Nout).
elif wcsinfo.Nin != 2 or wcsinfo.Nout != 2:
   print( "The world coordinate system is not 2-dimensional" )

#  Proceed if the WCS information was read OK.
else:
   ...

</pre>




<h4>...Display AST Data</h4>
<pre class=pycode>
#  Display the internal representation of the AST FrameSet
   print( wcsinfo )

#  or alternatively...
   wcsinfo.show()
</pre>

<h4>...Convert Between Pixel and World Coordinates</h4>
<pre class=pycode>

#  Store the x and y pixel coordinates at 3 points in the FITS image
   xpixel = [ 120., 150., 180. ]
   ypixel = [ 175., 150., 125. ]

#  Convert to world coordinates.
   ( xworld, yworld ) = wcsinfo.tran( [ xpixel, ypixel ] )

#  Convert back to pixel coordinates.
   ( xpix, ypix ) = wcsinfo.tran( [ xworld, yworld ], False )

</pre>




<h4>...Test if a WCS is a Celestial Coordinate System</h4>
<pre class=pycode>

#  Obtain a pointer to the current Frame and determine if it is a SkyFrame.
#  The frame index argument could have been omitted in this case since it
#  defaults to Ast.CURRENT.
   frame = wcsinfo.getframe( Ast.CURRENT )
   issky = isinstance( frame, Ast.SkyFrame )

#  Or equivalently.
   issky = frame.issskyframe()

</pre>




<h4>...Format Coordinates for Display</h4>
<pre class=pycode>

# Loop round all the positions to be formatted
   for (x,y) in zip( xworld, yworld):

#  Get the formatted value for the first WCS axis, and append the units
#  string. Then do the same for the second WCS axis.
      xtext = wcsinfo.format( 1, x ) + " " + wcsinfo.Unit_1
      ytext = wcsinfo.format( 2, y ) + " " + wcsinfo.Unit_2

#  Print both values.
      print( "Position = "+xtext+", "+ytext )

</pre>




<h4>...Display Coordinates as they are Transformed</h4>
<pre class=pycode>

#  Tell the Mapping to report each position as it is transformed.
   wcsinfo.Report = True

#  Convert to world coordinates.
   ( xworld, yworld ) = wcsinfo.tran( [ xpixel, ypixel ] )

#  Convert back to pixel coordinates.
   ( xpix, ypix ) = wcsinfo.tran( [ xworld, yworld ], False )

</pre>

<h4>...Read Coordinates Entered by a User</h4>
<pre class=pycode>

#  Obtain the number of coordinate axes (if not already known).
#  The values of Naxes and Nout are equal for a FrameSet.
   naxes = wcsinfo.Naxes

#  Loop to read each line of input text, in this case from the
#  standard input stream.
   while True:
      text = input( "Coords: " )
      if text == "":
         break
      else:

#  Attempt to read a coordinate for each axis.
         start = 0
         end = len( text )
         for iaxis in range( 1, naxes ):
            ( n, axis_value ) = wcsinfo.unformat( iaxis, text[ start ] )

#  If nothing was read and this is not the first axis or the end-of-string,
#  try stepping over a separator and reading again.
            if n == 0 and ( iaxis > 1 ) && ( start < end ):
               start += 1
               ( n, axis_value ) = wcsinfo.unformat( iaxis, text[ start ] )

#  Quit if nothing was read, otherwise move on to the next coordinate. */
            if n == 0 :
               break
            start += n

#  Store axis value
            pos.append( axis_value )

#  Error in input data at character text[n]. */
         if start < end or n == 0:
            print( "Could not read supplied coordinates")
            break

#  Coordinates were read OK.
         else:
            print( pos )

</pre>


</body>
</html>
